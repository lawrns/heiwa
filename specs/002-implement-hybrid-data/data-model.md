# Data Model: Hybrid Data Access Architecture

## Overview
The hybrid data access architecture integrates two data sources:
1. **Direct Supabase access** for room listings and read operations
2. **Admin system APIs** for booking operations and complex business logic

## Core Entities

### Room Entity
**Source**: Supabase database (rooms table)
**Access Pattern**: Direct read access from website

```typescript
interface Room {
  id: string;              // Primary key
  name: string;            // Display name
  capacity: number;        // Maximum guests
  bookingType: 'whole' | 'perBed';  // Reservation type
  pricing: {
    standard: number;      // Base price
    offSeason: number;     // Off-season price
    camp: Record<string, number> | { perBed: number }; // Complex pricing
  };
  amenities: string[];     // Feature list
  bedTypes: string[];      // Bed configurations
  description?: string;    // Optional description
  images: string[];        // Image URLs
  isActive: boolean;       // Availability flag
}
```

**Validation Rules**:
- `name` must be non-empty string
- `capacity` must be positive integer
- `isActive` must be true for display
- `images` array must contain at least one valid URL

### Booking Entity
**Source**: Admin system API
**Access Pattern**: API calls for creation and availability checks

```typescript
interface Booking {
  id?: string;             // Generated by admin system
  clientName: string;      // Guest name
  email: string;           // Contact email
  phone?: string;          // Optional phone
  checkIn: string;         // ISO date string
  checkOut: string;        // ISO date string
  roomType: string;        // Room ID
  guests: number;          // Guest count
  message?: string;        // Special requests
  status: 'pending' | 'confirmed' | 'cancelled';
}
```

**Validation Rules**:
- `checkIn` must be before `checkOut`
- `guests` must be positive integer
- `email` must be valid format
- `status` must be valid enum value

### Availability Entity
**Source**: Admin system API
**Access Pattern**: Real-time API queries

```typescript
interface AvailabilityCheck {
  roomId: string;
  checkIn: string;
  checkOut: string;
  available: boolean;
  price?: number;
  message?: string;        // Reason if unavailable
}
```

## Data Flow Architecture

### Read Operations (Direct DB Access)
```
Website → Supabase → Room listings
       → Supabase → Static content
```

**Benefits**:
- Fast response times
- No external dependencies for basic content
- Works during admin system outages

### Write Operations (Admin API)
```
Website → Admin API → Booking creation
       → Admin API → Availability checks
       → Admin API → Price calculations
```

**Benefits**:
- Business logic validation
- Centralized booking management
- Real-time availability updates

## Data Consistency Strategy

### Single Source of Truth
- **Admin system** owns all booking and pricing logic
- **Supabase database** serves as shared data store
- **Website** reads current state, delegates changes to admin

### Synchronization Approach
1. **Immediate sync**: Changes in admin reflect immediately in website
2. **Fallback data**: Static room data when DB unavailable
3. **Graceful degradation**: Basic functionality preserved during outages

## Error Handling Model

### Network Failures
- **Supabase unavailable**: Fall back to static room data
- **Admin API unavailable**: Show "booking temporarily unavailable" message
- **Partial failures**: Continue with available functionality

### Data Validation
- **Client-side**: Basic input validation
- **API validation**: Business rule enforcement
- **Fallback validation**: Ensure minimum viable data structure

## Performance Considerations

### Caching Strategy
- **Room data**: Cache in browser for session
- **Availability**: Real-time checks (no caching)
- **Static assets**: CDN caching via Next.js

### Query Optimization
- **Supabase queries**: Indexed fields for fast lookups
- **API calls**: Minimal payload, efficient serialization
- **Error responses**: Lightweight error structures

